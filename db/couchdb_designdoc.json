{
  "docs": [
    {
      "_id": "_design/ripple",
      "language": "javascript",
      "lists": {
        "constituents": "function(head, req) {\n    var view = req.path.slice(2 + req.path.indexOf(\"_list\"))[0];\n    if (view === \"eventsByAccount\") {\n\n        var stream = false;\n        if (req.query.stream || req.query.include_stats)\n            stream = true;\n\n        var constituents = {\n            \"users\": [],\n            \"gateways\": [],\n            // \"hot_wallets\": [],\n            \"market_makers\": [],\n            \"merchants\": []\n        };\n        var row;\n        while (row = getRow()) {\n            var acct = row.key[0];\n\n            if (row.value.TrustSet > 100) {\n                // gateway\n                if (!stream) {\n                    constituents.gateways.push(acct);\n                } else {\n                    send({type: \"gateway\", acct: acct, stats: row.value});\n                }\n            // } else if (row.value.Payment > 200 && row.value.TrustSet < 100){\n            //     // hot wallet\n            //     if (!stream) {\n            //         constituents.hot_wallets.push(acct);\n            //     } else {\n            //         send({type: \"hot_wallet\", acct: acct, stats: row.value});\n            //     }\n            } else if (row.value.OfferCreate + row.value.OfferCancel > 100) {\n                // market maker\n                if (!stream) {\n                    constituents.market_makers.push(acct);\n                } else {\n                    send({type: \"market_maker\", acct: acct, stats: row.value});\n                }\n            } else if (row.value.Incoming_Payment > 200) {\n                // merchant\n                if (!stream) {\n                    constituents.merchants.push(acct);\n                } else {\n                    send({type: \"merchant\", acct: acct, stats: row.value});\n                }\n            } else {\n                // other\n                if (!stream) {\n                    constituents.users.push(acct);\n                } else {\n                    send({type: \"user\", acct: acct, stats: row.value});\n                }\n            }\n        }\n        if (!stream)\n            send(JSON.stringify(constituents));\n    } else {\n        send('Error, this view can only be used with the view \"eventsByAccount\"');\n    }\n}",
        "csv": "function(head, req) {\n    var row;\n    while (row = getRow()) {\n        var row_array = [];\n\n        if (typeof row.key === \"object\") {\n            var key = JSON.parse(row.key);\n            Object.keys(key).forEach(function(k) {\n                row_array.push(JSON.stringify(key[k]));\n            });\n        } else if (typeof row.key !== \"null\" || typeof row.key !== \"undefined\") {\n            row_array.push(row.key);\n        }\n\n        if (typeof row.value === \"object\") {\n            var value = JSON.parse(row.value);\n            Object.keys(value).forEach(function(k) {\n                row_array.push(JSON.stringify(value[k]));\n            });\n        } else if (typeof row.value !== \"null\" || typeof row.value !== \"undefined\") {\n            row_array.push(row.value);\n        }\n\n        var csv_row = row_array.join(',') + \"\\n\";\n        send(csv_row);\n    }\n}",
        "gateways": "function(head, req) {\n    var view = req.path.slice(2 + req.path.indexOf(\"_list\"))[0];\n    if (view === \"trustlineStatsByAccount\" || view === \"trustlineStatsByCurrency\") {\n\n        var row;\n        while (row = getRow()) {\n            if (row.value.incoming > 50 \n                && row.value.balance_change < 0) {\n                send(JSON.stringify(row) + \"\\n\");\n            }\n        }\n\n    } else {\n        send('Error, this view can only be used with the views \"trustlineStatsByCurrency\" and \"trustlineStatsByAccount\"');\n    }\n}",
        "hotwalletpotentials": "function(head, req) {\n    var view = req.path.slice(2 + req.path.indexOf(\"_list\"))[0];\n\n    if (view === \"trustlinesByAccount\") {\n        if (req.query.group_level === 2) {\n            var row;\n            var potentials;\n            while (row = getRow()) {\n                if (row.value.outgoing < 5\n                    && row.value.balance > 0) {\n\n                    var acct = row.key[0],\n                        curr = row.key[1];\n\n                    if (typeof potentials[acct] === \"undefined\")\n                        potentials[acct] = {};\n                    if (typeof potentials[acct][curr] === \"undefined\")\n                        potentials[acct][curr] = {};\n\n                    potentials[acct][curr].in = row.value.incoming;\n                    potentials[acct][curr].out = row.value.outgoing;\n                    potentials[acct][curr].bal = row.value.balance_change;\n                    potentials[acct][curr].trusted_parties = row.value.trusted_parties;\n                }\n            }\n            send(JSON.stringify(potentials));\n        } else {\n            send('Error, this view should be used with query group_level=2');\n        }\n    } else {\n        send('Error, this view can only be used with the view \"trustlinesByAccount\"');\n    }\n}",
        "sort": "function(head, req) {\n    var rows = [],\n        row;\n    while (row = getRow()) {\n        rows.push(row);\n    }\n    rows.sort(function(a, b) {\n        if (b.value > a.value) {\n            return 1;\n        } else {\n            return -1;\n        }\n    });\n    send(JSON.stringify({\"rows\": rows}));\n}",
        "streamRows": "function(head, req) {\n    var row;\n    while(row = getRow()){\n        send(JSON.stringify([row.key, row.value]) + \"\\n\");\n    }\n}",
        "trades": "function(head, req) {\n    var view = req.path.slice(2 + req.path.indexOf(\"_list\"))[0];\n    if (view === \"offersExercised\") {\n        if (req.query.group === \"true\") {\n\n            var row;\n            while (row = getRow()) {\n                var date_arr = row.key.slice(2),\n                    price = row.value.volume_weighted_avg,\n                    volume = row.value.vwav_denominator;\n\n                var timestamp = pad(date_arr[0],4) + \"-\" + pad(date_arr[1],2) + \"-\" + pad(date_arr[2],2) \n                                + \"T\" + pad(date_arr[3],2) + \":\" + pad(date_arr[4],2) + \":\" + pad(date_arr[5],2) + \"+0000\";\n\n                send(JSON.stringify([timestamp, price, volume]) + \"\\n\");\n            }\n        } else {\n            send('Error, this view should be used with query group=true');\n        }\n    } else {\n        send('Error, this view can only be used with the view \"offersExercised\"');\n    }\n\n    function pad (number, digits) {\n        var num_str = String(number);\n        while (num_str.length < digits) {\n            num_str = \"0\" + num_str;\n        }\n        return num_str;\n    }\n}",
        "xrp": "function(head, req) {\n    var view = req.path.slice(2 + req.path.indexOf(\"_list\"))[0];\n    if (view === \"xrp_totals\") {\n        if (req.query.group_level === \"1\") {\n\n            var total_only = false;\n            if (req.query.total_only)\n                total_only = true;\n\n            var xrp_total = 0;\n            var row;\n            while (row = getRow()) {\n                xrp_total += row.value[0];\n                if (!total_only)\n                    send(JSON.stringify([row.key[0], row.value[0]]));\n            }\n            if (total_only)\n                send(\"XRP Total: \" + (xrp_total / 1000000.0));\n\n        } else {\n            send('Error, this view should be used with query group_level=1');\n        }\n    } else {\n        send('Error, this view can only be used with the view \"xrp_totals\"');\n    }\n}"
      },
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "account_tx": {
          "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( doc.transactions[ t ].metaData.TransactionResult === \"tesSUCCESS\" ) {\n\n      emit( [ tx.Account ].concat( timestamp ), tx );\n\n    }\n\n  } );\n}"
        },
        "accountsCreated": {
          "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== \"tesSUCCESS\" ) {\n      return;\n    }\n\n      tx.metaData.AffectedNodes.forEach( function( affNode ) {\n\n        if ( affNode.CreatedNode && affNode.CreatedNode.LedgerEntryType === \"AccountRoot\" ) {\n\n          emit( timestamp, affNode.CreatedNode.NewFields.Account );\n          \n        }\n\n      } );\n  } );\n}",
          "reduce": "_count"
        },
        "eventsByAccount": {
          "map": "function (doc) {\n\n    var time = new Date(doc.close_time_timestamp),\n        timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                     time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n        var tx = doc.transactions[t];\n\n        if (doc.transactions[t].metaData.TransactionResult !== \"tesSUCCESS\") \n            continue;\n\n        emit([tx.Account].concat(timestamp), tx);\n        if (typeof tx.Destination === \"string\") {\n            emit([tx.Destination].concat(timestamp), tx);\n        }\n    }\n}",
          "reduce": "function (keys, values, rereduce) {\n\n    if (!rereduce) {\n\n        var types = {\n            Payment: 0,\n            OfferCreate: 0,\n            OfferCancel: 0,\n            TrustSet: 0,\n            Incoming_Payment: 0\n        };\n        var total = 0;\n\n        for (var v = 0, vlen = values.length; v < vlen; v++) {\n            var tx = values[v];\n\n            if (tx.Account === keys[v][0]) {\n                // tx initiated by this account\n\n                if (types.hasOwnProperty(tx.TransactionType)) {\n                    types[tx.TransactionType] += 1;\n                    total += 1;\n                }\n            } \n            else if (tx.TransactionType === \"Payment\" && tx.Destination === keys[v][0]) {\n                types[Incoming_Payment] += 1;\n            }\n        }\n\n        types.Total_Initiated = total;\n        return types;\n\n    } else {\n\n        var results = values[0];\n        var tx_types = Object.keys(results);\n\n        for (var v = 1, vlen = values.length; v < vlen; v++) {\n            for (var t = 0; t < tx_types.length; t++) {\n                var tx_type = tx_types[t];\n                results[tx_type] += values[v][tx_type];\n            }\n        }\n\n        return results;\n    }\n}"
        },
        "feesPaid": {
          "map": "function( doc ) {\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    emit( timestamp, parseInt( tx.Fee, 10 ) );\n\n  } );\n}",
          "reduce": "_sum"
        },
        "indexesAndTimesByTime": {
          "map": "function (doc) {\n    var time = new Date(doc.close_time_timestamp),\n        timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                     time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n    var ledger_index = doc.ledger_index;\n\n    emit(timestamp, ledger_index);\n\n}"
        },
        "ledgerClosesByTime": {
          "map": "function (doc) {\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  emit( timestamp, 1 );\n}",
          "reduce": "_sum"
        },
        "offersExercised": {
          "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== 'tesSUCCESS' ) {\n      return;\n    }\n\n    if ( tx.TransactionType !== 'Payment' && tx.TransactionType !== 'OfferCreate' ) {\n      return;\n    }\n\n    tx.metaData.AffectedNodes.forEach( function( affNode ) {\n\n      var node = affNode.ModifiedNode || affNode.DeletedNode;\n\n      if ( !node || node.LedgerEntryType !== 'Offer' ) {\n        return;\n      }\n\n      if ( !node.PreviousFields || !node.PreviousFields.TakerPays || !node.PreviousFields.TakerGets ) {\n        return;\n      }\n\n      var exchangeRate = node.exchange_rate,\n        payCurr,\n        payAmnt,\n        getCurr,\n        getAmnt;\n\n      if ( typeof node.PreviousFields.TakerPays === \"object\" ) {\n        payCurr = [ node.PreviousFields.TakerPays.currency, node.PreviousFields.TakerPays.issuer ];\n        payAmnt = node.PreviousFields.TakerPays.value - node.FinalFields.TakerPays.value;\n      } else {\n        payCurr = [ \"XRP\" ];\n        payAmnt = ( node.PreviousFields.TakerPays - node.FinalFields.TakerPays ) / 1000000.0; // convert from drops\n        exchangeRate = exchangeRate / 1000000.0;\n      }\n\n      if ( typeof node.PreviousFields.TakerGets === \"object\" ) {\n        getCurr = [ node.PreviousFields.TakerGets.currency, node.PreviousFields.TakerGets.issuer ];\n        getAmnt = node.PreviousFields.TakerGets.value - node.FinalFields.TakerGets.value;\n      } else {\n        getCurr = [ \"XRP\" ];\n        getAmnt = ( node.PreviousFields.TakerGets - node.FinalFields.TakerGets ) / 1000000.0;\n        exchangeRate = exchangeRate * 1000000.0;\n      }\n\n      emit( [ payCurr, getCurr ].concat( timestamp ), [ payAmnt, getAmnt, exchangeRate ] );\n      emit( [ getCurr, payCurr ].concat( timestamp ), [ getAmnt, payAmnt, 1 / exchangeRate ] );\n\n    } );\n  } );\n}",
          "reduce": "function( keys, values, rereduce ) {\n\n  var stats;\n\n  if ( !rereduce ) {\n\n    var firstTime = keys[ 0 ][ 0 ].slice( 2 ),\n      firstPrice;\n\n    if ( values[ 0 ][ 2 ] ) { // exchangeRate\n      firstPrice = parseFloat(values[ 0 ][ 2 ]);\n    } else {\n      firstPrice = values[ 0 ][ 0 ] / values[ 0 ][ 1 ];\n    }\n\n    // initial values\n    stats = {\n      openTime: firstTime,\n      closeTime: firstTime,\n\n      open: firstPrice,\n      close: firstPrice,\n      high: firstPrice,\n      low: firstPrice,\n\n      curr1VwavNumerator: 0,\n      curr1Volume: 0,\n      curr2Volume: 0,\n      numTrades: 0\n    };\n\n    values.forEach( function( trade, index ) {\n\n      var tradeTime = keys[ index ][ 0 ].slice( 2 ),\n        tradeRate = trade[ 2 ] || ( trade[ 0 ] / trade[ 1 ] );\n\n      if ( lessThan( tradeTime, stats.openTime ) ) {\n        stats.openTime = tradeTime;\n        stats.open = tradeRate;\n      }\n\n      if ( lessThan( stats.closeTime, tradeTime ) ) {\n        stats.closeTime = tradeTime;\n        stats.close = tradeRate;\n      }\n\n      stats.high = Math.max( stats.high, tradeRate );\n      stats.low = Math.min( stats.low, tradeRate );\n      stats.curr1VwavNumerator += tradeRate * trade[ 0 ];\n      stats.curr1Volume += trade[ 0 ];\n      stats.curr2Volume += trade[ 1 ];\n      stats.numTrades++;\n\n    } );\n\n    stats.volumeWeightedAvg = stats.curr1VwavNumerator / stats.curr1Volume;\n\n    return stats;\n\n  } else {\n\n    stats = values[0];\n\n    values.forEach( function( segment, index ) {\n\n      // skip values[0]\n      if (index === 0) {\n        return;\n      }\n\n      if ( lessThan( segment.openTime, stats.openTime ) ) {\n        stats.openTime = segment.openTime;\n        stats.open = segment.open;\n      }\n      if ( lessThan( stats.closeTime, segment.closeTime ) ) {\n        stats.closeTime = segment.closeTime;\n        stats.close = segment.close;\n      }\n\n      stats.high = Math.max( stats.high, segment.high );\n      stats.low = Math.min( stats.low, segment.low );\n\n      stats.curr1VwavNumerator += segment.curr1VwavNumerator;\n      stats.curr1Volume += segment.curr1Volume;\n      stats.curr2Volume += segment.curr2Volume;\n      stats.numTrades += segment.numTrades;\n\n    } );\n\n    stats.volumeWeightedAvg = stats.curr1VwavNumerator / stats.curr1Volume;\n\n    return stats;\n  }\n\n\n  function lessThan( arr1, arr2 ) {\n    if ( arr1.length !== arr2.length )\n      return false;\n\n    for ( var i = 0; i < arr1.length; i++ ) {\n      if ( arr1[ i ] < arr2[ i ] ) {\n        return true;\n      } else if ( arr1[ i ] > arr2[ i ] ) {\n        return false;\n      } else {\n        continue;\n      }\n    }\n\n    return false;\n  }\n}"
        },
        "paymentCountsBetweenAccounts": {
          "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== 'tesSUCCESS' || tx.TransactionType !== 'Payment' )\n      return;\n\n    var srcAccount = tx.Account,\n      dstAccount = tx.Destination,\n      dstCurrency,\n      dstAmount;\n\n    if ( typeof tx.Amount === 'object' ) {\n      dstCurrency = [ tx.Amount.currency, tx.Amount.issuer ];\n      dstAmount = tx.Amount.value;\n    } else {\n      dstCurrency = [ 'XRP' ];\n      dstAmount = tx.Amount;\n    }\n\n    emit( [ srcAccount, dstCurrency, dstAccount ].concat( timestamp ), 1 );\n\n  } );\n\n}",
          "reduce": "_sum"
        },
        "paymentTypesByTime": {
          "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach(function(tx){\n\n    if (tx.metaData.TransactionResult !== 'tesSUCCESS' || tx.TransactionType !== 'Payment') {\n      return;\n    }\n\n    var srcAcct = tx.Account,\n      dstAccount = tx.Destination,\n      affNodes = tx.metaData.AffectedNodes,\n      srcRippleStateFields = [],\n      srcCurr,\n      dstCurr;\n\n    if (typeof tx.Amount === 'object') {\n      dstCurr = [tx.Amount.currency, tx.Amount.issuer];\n    } else {\n      dstCurr = ['XRP'];\n    }\n\n    for (var a = 0; a < affNodes.length; a++) {\n\n      var node = affNodes[a].CreatedNode || affNodes[a].ModifiedNode || affNodes[a].DeletedNode;\n\n      // bridged through XRP if it modified an AccountRoot that\n      // does not belong either to the srcAcct or dstAcct\n      if (node.LedgerEntryType === 'AccountRoot' && node.FinalFields \n        && node.FinalFields.Account !== srcAcct && node.FinalFields.Account !== dstAcct) {\n\n        emit(timestamp, {'crossCurrXrpBridge': 1});\n        return;\n      }\n\n      // look for how many RippleState nodes involving the srcAcct were affected\n      if (node.LedgerEntryType === 'RippleState') {\n\n        var fields = node.FinalFields || node.NewFields;\n\n        if (fields.HighLimit.issuer === srcAcct || fields.LowLimit.issuer === srcAcct) {\n          srcRippleStateFields.push(fields);\n        }\n      }\n    }\n\n    if (srcRippleStateFields.length === 0) {\n\n      // affected no RippleState nodes belonging to the srcAcct\n      // so the srcCurr must be XRP\n      srcCurr = ['XRP'];\n\n    } else if (srcRippleStateFields.length === 1) {\n\n      // only 1 RippleState node modified so the srcCurr is [currency, issuer]\n      // of whichever of the (High/Low)Limit is not the srcAcct\n      if (srcRippleStateFields[0].HighLimit.issuer === srcAcct) {\n\n        srcCurr = [srcRippleStateFields[0].LowLimit.currency, srcRippleStateFields[0].LowLimit.issuer];\n\n      } else if (srcRippleStateFields[0].LowLimit.issuer === srcAcct) {\n\n        srcCurr = [srcRippleStateFields[0].HighLimit.currency, srcRippleStateFields[0].HighLimit.issuer];\n\n      }\n\n    } else if (srcRippleStateFields.length >= 2) {\n      \n      // check if any of the fields involve currencies other than the dst\n      var crossCurrency = srcRippleStateFields.some(function(fields){\n\n        if (fields.HighLimit.currency !== dstCurr[0] || fields.LowLimit.currency !== dstCurr[0]) {\n          return true;\n        } else {\n          return false;\n        }\n\n      });\n\n      if (crossCurrency) {\n\n        emit(timestamp, {'crossCurrNoXrpBridge': 1});\n        return;\n\n      } else {\n\n        emit(timestamp, {'sameCurrCrossGate': 1});\n        return;\n\n      }\n\n    }\n\n    if (srcCurr[0] !== dstCurr[0]) {\n\n      emit(timestamp, {'crossCurrNoXrpBridge': 1});\n\n    } else if (srcCurr[1] && dstCurr[1] && srcCurr[1] === dstCurr[1]) {\n\n      emit(timestamp, {'sameCurrCrossGate': 1});\n\n    } else if (srcCurr[0] === 'XRP' && dstCurr[0] === 'XRP') {\n\n      emit(timestamp, {'xrpToXrp': 1});\n\n    } else {\n\n      emit(timestamp, {'sameCurrSameGate': 1});\n\n    }\n\n  });\n\n}",
          "reduce": "function( keys, values, rereduce ) {\n\n  var stats = {};\n\n  values.forEach( function( val ) {\n\n    Object.keys( val ).forEach( function( txType ) {\n      if ( !stats[ txType ] ) {\n        stats[ txType ] = 0;\n      }\n\n      stats[ txType ] += val[ txType ];\n      \n    } );\n  } );\n\n  return stats;\n\n}"
        },
        "paymentValuesBetweenAccounts": {
          "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== 'tesSUCCESS' || tx.TransactionType !== 'Payment' )\n      return;\n\n    var srcAccount = tx.Account,\n      dstAccount = tx.Destination,\n      dstCurrency,\n      dstAmount;\n\n    if ( typeof tx.Amount === 'object' ) {\n      dstCurrency = [ tx.Amount.currency, tx.Amount.issuer ];\n      dstAmount = parseFloat( tx.Amount.value );\n    } else {\n      dstCurrency = [ 'XRP' ];\n      dstAmount = parseFloat( tx.Amount );\n    }\n\n    emit( [ srcAccount, dstCurrency, dstAccount ].concat( timestamp ), dstAmount );\n\n  } );\n\n}",
          "reduce": "_sum"
        },
        "paymentValuesByAccount": {
          "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== 'tesSUCCESS' || tx.TransactionType !== 'Payment' )\n      return;\n\n    var srcAccount = tx.Account,\n      dstAccount = tx.Destination,\n      dstCurrency,\n      dstAmount;\n\n    if ( typeof tx.Amount === 'object' ) {\n      dstCurrency = [ tx.Amount.currency, tx.Amount.issuer ];\n      dstAmount = parseFloat( tx.Amount.value );\n    } else {\n      dstCurrency = [ 'XRP' ];\n      dstAmount = parseFloat( tx.Amount );\n    }\n\n    emit( [ srcAccount, dstCurrency ].concat( timestamp ), dstAmount );\n\n  } );\n\n}",
          "reduce": "_sum"
        },
        "paymentValuesReceivedByCurrency": {
          "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== 'tesSUCCESS' || tx.TransactionType !== 'Payment' )\n      return;\n\n    var dstCurrency,\n      dstAmount;\n\n    if ( typeof tx.Amount === 'object' ) {\n      dstCurrency = [ tx.Amount.currency, tx.Amount.issuer ];\n      dstAmount = parseFloat( tx.Amount.value );\n    } else {\n      dstCurrency = [ 'XRP' ];\n      dstAmount = parseFloat( tx.Amount );\n    }\n\n    emit( [ dstCurrency ].concat( timestamp ), dstAmount );\n\n  } );\n\n}",
          "reduce": "_sum"
        },
        "sandbox": {
          "trustlineBalances": {
            "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== \"tesSUCCESS\" )\n      return;\n\n    tx.metaData.AffectedNodes.forEach( function( affNode ) {\n\n      var node = affNode.CreatedNode || affNode.ModifiedNode || affNode.DeletedNode;\n\n      if ( !node || node.LedgerEntryType !== \"RippleState\" ) {\n        return;\n      }\n\n      var currency,\n        highParty,\n        lowParty,\n        prevBal,\n        finalBal,\n        balChange;\n\n      if ( node.NewFields ) {\n\n        // trustline created with non-negative balance\n\n        if ( parseFloat( node.NewFields.Balance.value ) === 0 ) {\n          return;\n        }\n\n        currency  = node.NewFields.Balance.currency;\n        highParty = node.NewFields.HighLimit.issuer;\n        lowParty  = node.NewFields.LowLimit.issuer;\n\n        prevBal   = 0;\n        finalBal  = parseFloat( node.NewFields.Balance.value );\n        balChange = finalBal - prevBal;\n        if (node.PreviousFields) log(node.PreviousFields);\n        \n      } else if ( node.PreviousFields && node.PreviousFields.Balance ) {\n\n        // trustline balance modified\n\n        currency  = node.FinalFields.Balance.currency;\n        lowParty  = node.FinalFields.LowLimit.issuer;\n        highParty = node.FinalFields.HighLimit.issuer;\n\n        prevBal   = parseFloat( node.PreviousFields.Balance.value );\n        finalBal  = parseFloat( node.FinalFields.Balance.value );\n        balChange = finalBal - prevBal;\n\n      } else if ( node.FinalFields && node.FinalFields.Balance) {\n        \n        currency  = node.FinalFields.Balance.currency;\n        lowParty  = node.FinalFields.LowLimit.issuer;\n        highParty = node.FinalFields.HighLimit.issuer;        \n\n        prevBal   = 0;\n        finalBal  = parseFloat( node.FinalFields.Balance.value );\n        balChange = finalBal - prevBal;\n                \n      } else {\n        log(\"no prev, no final\");\n        log(node);\n        return;\n      } \n\n      emit( [ lowParty, currency ].concat( timestamp ), balChange );\n      emit( [ highParty, currency ].concat( timestamp ), ( 0 - balChange ) );\n\n    } );\n  } );\n}"
          }
        },
        "totalValueSent": {
          "map": "// function map (doc) {\nfunction(doc) {\n\n  var time = new Date(doc.close_time_timestamp);\n  var timestamp = [\n    time.getUTCFullYear(), \n    time.getUTCMonth(), \n    time.getUTCDate(),\n    time.getUTCHours(), \n    time.getUTCMinutes(), \n    time.getUTCSeconds()\n  ];\n\n  doc.transactions.forEach(function(tx){\n\n    if (tx.metaData.TransactionResult !== 'tesSUCCESS') {\n      return;\n    }\n\n    if (tx.TransactionType !== 'Payment' && tx.TransactionType !== 'OfferCreate') {\n      return;\n    }\n\n    var src_balance_changes = parseBalanceChanges(tx, tx.Account);\n\n    if (src_balance_changes.length > 0) {\n      src_balance_changes.forEach(function(bal_change){\n        emit([bal_change.currency, bal_change.issuer].concat(timestamp), 0 - parseFloat(bal_change.value));\n      });\n    }\n\n  });\n\n  function parseBalanceChanges (tx, address) {\n\n    var addressBalanceChanges = [];\n\n    tx.metaData.AffectedNodes.forEach(function(affNode){\n\n      var node = affNode.CreatedNode || affNode.ModifiedNode || affNode.DeletedNode;\n\n      // Look for XRP balance change in AccountRoot node\n      if (node.LedgerEntryType === 'AccountRoot') {\n\n        var xrpBalChange = parseAccountRootBalanceChange(node, address);\n        if (xrpBalChange) {\n\n          // Add back the fee back if address is the sender\n          if (address === tx.Account) {\n            xrpBalChange.value += dropsToXrp(tx.Fee);\n          }\n\n          addressBalanceChanges.push(xrpBalChange);\n        }\n\n      }\n\n      // Look for trustline balance change in RippleState node\n      if (node.LedgerEntryType === 'RippleState') {\n\n        var currBalChange = parseTrustlineBalanceChange(node, address);\n        if (currBalChange) {\n          addressBalanceChanges.push(currBalChange);\n        }\n\n      }\n\n    });\n\n    return addressBalanceChanges;\n\n  }\n\n\n  function parseAccountRootBalanceChange (node, address) {\n\n    if (node.NewFields) {\n\n      if (node.NewFields.Account === address) {\n        return {\n          value: dropsToXrp(node.NewFields.Balance),\n          currency: 'XRP',\n          issuer: ''\n        };\n      }\n\n    } else if (node.FinalFields) {\n\n      if (node.FinalFields.Account === address) {\n\n        var finalBal = dropsToXrp(node.FinalFields.Balance),\n          prevBal = dropsToXrp(node.PreviousFields.Balance),\n          balChange = parseFloat(finalBal) - parseFloat(prevBal);\n        \n        return {\n          value: balChange,\n          currency: 'XRP',\n          issuer: ''\n        };\n      }\n    }\n\n    return null;\n  }\n\n  function parseTrustlineBalanceChange (node, address) {\n\n    var balChange = {\n        value: 0,\n        currency: '',\n        issuer: ''\n      }, \n      trustHigh,\n      trustLow,\n      trustBalFinal,\n      trustBalPrev;\n\n    if (node.NewFields) {\n      trustHigh = node.NewFields.HighLimit;\n      trustLow = node.NewFields.LowLimit;\n      trustBalFinal = parseFloat(node.NewFields.Balance.value);\n    } else {\n      trustHigh = node.FinalFields.HighLimit;\n      trustLow = node.FinalFields.LowLimit;\n      trustBalFinal = parseFloat(node.FinalFields.Balance.value); \n    }\n\n    if (node.PreviousFields && node.PreviousFields.Balance) {\n      trustBalPrev = parseFloat(node.PreviousFields.Balance.value);\n    } else {\n      trustBalPrev = 0;\n    }\n\n    // Set value\n    if (trustLow.issuer === address) {\n      balChange.value = parseFloat(trustBalFinal) - parseFloat(trustBalPrev);\n    } else if (trustHigh.issuer === address) {\n      balChange.value = 0 - (parseFloat(trustBalFinal) - parseFloat(trustBalPrev));\n    } else {\n      return null;\n    }\n\n    // Set currency\n    balChange.currency = (node.NewFields || node.FinalFields).Balance.currency;\n\n    // Set issuer\n    if ((parseFloat(trustHigh.value) === 0 && parseFloat(trustLow.value) === 0) ||\n      (parseFloat(trustHigh.value) > 0 && parseFloat(trustLow.value) > 0)) {\n\n      if (parseFloat(trustBalFinal) > 0 || parseFloat(trustBalPrev) > 0) {\n        balChange.issuer = trustLow.issuer;\n      } else {\n        balChange.issuer = trustHigh.issuer;\n      }\n\n    } else if (parseFloat(trustHigh.value) > 0) {\n      balChange.issuer = trustLow.issuer;\n    } else if (parseFloat(trustLow.value) > 0) {\n      balChange.issuer = trustHigh.issuer;\n    }\n\n    return balChange;\n\n  }\n\n  function dropsToXrp (drops) {\n    return parseFloat(drops) / 1000000.0;\n  }\n\n  function xrpToDrops (xrp) {\n    return parseFloat(xrp) * 1000000.0;\n  }\n\n}\n\n// function emit(key, value) {\n//   console.log('key: ' + JSON.stringify(key) + ' value: ' + value);\n// }\n\n// map({\n//       \"accepted\": true,\n//       \"account_hash\": \"ADDDCDB0C57D4F6010713C8A97C09A39EBD9CFF339DD2020B081E87DF3D1FAE0\",\n//       \"close_time\": 444459220,\n//       \"close_time_human\": \"2014-Jan-31 04:53:40\",\n//       \"close_time_resolution\": 10,\n//       \"closed\": true,\n//       \"hash\": \"E02BBDE4A5BB721C72BBF4C2139A0A22637E43A46DEC44B4BF85B8A20F765970\",\n//       \"ledger_hash\": \"E02BBDE4A5BB721C72BBF4C2139A0A22637E43A46DEC44B4BF85B8A20F765970\",\n//       \"ledger_index\": \"4718685\",\n//       \"parent_hash\": \"B3BA5147905C6017354B408D1EF0C9AD0EB3E352BFAB8521B6D392E44E7F1B3D\",\n//       \"seqNum\": \"4718685\",\n//       \"totalCoins\": \"99999998050649525\",\n//       \"total_coins\": \"99999998050649525\",\n//       \"transaction_hash\": \"E7422BEA4FE1789B3EFFEB2293436C371F69F08904EAC7C17C29D64A643A9B29\",\n//       \"transactions\": [\n//         {\n//           \"Account\": \"rU2DL7DwxxEjkRFV6uuSZtmJiosV5YgetS\",\n//           \"Amount\": {\n//             \"currency\": \"BTC\",\n//             \"issuer\": \"rLpq5RcRzA8FU1yUqEPW4xfsdwon7casuM\",\n//             \"value\": \"0.0001\"\n//           },\n//           \"Destination\": \"rLpq5RcRzA8FU1yUqEPW4xfsdwon7casuM\",\n//           \"Fee\": \"15\",\n//           \"Flags\": 0,\n//           \"Paths\": [\n//             [\n//               {\n//                 \"account\": \"rfYv1TXnwgDDK4WQNbFALykYuEBnrR4pDX\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rsZJQzsexY63t8LdkKhFdkqc29Bh2946Uh\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               }\n//             ],\n//             [\n//               {\n//                 \"account\": \"rfYv1TXnwgDDK4WQNbFALykYuEBnrR4pDX\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"r9LqFsCMME6NNSFkb5wmPYaUaf1AzgbKyc\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               }\n//             ],\n//             [\n//               {\n//                 \"account\": \"rfYv1TXnwgDDK4WQNbFALykYuEBnrR4pDX\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rGe5oH9mzzJ5CsfUJhHhraUCrkfY7zEQVV\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               }\n//             ],\n//             [\n//               {\n//                 \"account\": \"rfYv1TXnwgDDK4WQNbFALykYuEBnrR4pDX\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rnziParaNb8nsU4aruQdwYE3j5jUcqjzFm\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               }\n//             ]\n//           ],\n//           \"SendMax\": {\n//             \"currency\": \"BTC\",\n//             \"issuer\": \"rU2DL7DwxxEjkRFV6uuSZtmJiosV5YgetS\",\n//             \"value\": \"0.000101353803\"\n//           },\n//           \"Sequence\": 22,\n//           \"SigningPubKey\": \"03B5115CC780BA2EE3F0CA617BA8CC2408BB52A646A0585C236F1BA362F4F8EB89\",\n//           \"TransactionType\": \"Payment\",\n//           \"TxnSignature\": \"304402202D80325969238916D0D873D42684B62DFE8E22264413FC38F26F3512758F8AC202205D5482A0E9E5818250472BE80974083A8C9B093738EB20F3F17AAC7A45942AB8\",\n//           \"hash\": \"0D137EAAD7CC6296B4B330314846E89D484B2C4890936D3FE1969897A31F6D5C\",\n//           \"metaData\": {\n//             \"AffectedNodes\": [\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"-0.000894562910134798\"\n//                     },\n//                     \"Flags\": 131072,\n//                     \"HighLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rsZJQzsexY63t8LdkKhFdkqc29Bh2946Uh\",\n//                       \"value\": \"0.1\"\n//                     },\n//                     \"HighNode\": \"0000000000000000\",\n//                     \"LowLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",\n//                       \"value\": \"0\"\n//                     },\n//                     \"LowNode\": \"0000000000000113\"\n//                   },\n//                   \"LedgerEntryType\": \"RippleState\",\n//                   \"LedgerIndex\": \"235866687C354C777919CF68490F86E81CCF96E9F068765B964808DE7B97AEAF\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"-0.000994762910134798\"\n//                     }\n//                   },\n//                   \"PreviousTxnID\": \"1CCCFFCB3EBEBDB2F075186858927D4315CB2A93FB601E66FE70ECB07FE5902F\",\n//                   \"PreviousTxnLgrSeq\": 4699097\n//                 }\n//               },\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"0.001141447515872594\"\n//                     },\n//                     \"Flags\": 65536,\n//                     \"HighLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rfYv1TXnwgDDK4WQNbFALykYuEBnrR4pDX\",\n//                       \"value\": \"0\"\n//                     },\n//                     \"HighNode\": \"0000000000000033\",\n//                     \"LowLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rsZJQzsexY63t8LdkKhFdkqc29Bh2946Uh\",\n//                       \"value\": \"0.1\"\n//                     },\n//                     \"LowNode\": \"0000000000000000\"\n//                   },\n//                   \"LedgerEntryType\": \"RippleState\",\n//                   \"LedgerIndex\": \"2FAC03FAF21C97882149BC3D968431F947547E202841E703786E1B1229D904F0\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"0.001041247515872594\"\n//                     }\n//                   },\n//                   \"PreviousTxnID\": \"1CCCFFCB3EBEBDB2F075186858927D4315CB2A93FB601E66FE70ECB07FE5902F\",\n//                   \"PreviousTxnLgrSeq\": 4699097\n//                 }\n//               },\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Account\": \"rU2DL7DwxxEjkRFV6uuSZtmJiosV5YgetS\",\n//                     \"Balance\": \"172113760760\",\n//                     \"Flags\": 0,\n//                     \"OwnerCount\": 2,\n//                     \"Sequence\": 23\n//                   },\n//                   \"LedgerEntryType\": \"AccountRoot\",\n//                   \"LedgerIndex\": \"C32FC61866A3744D802E52F6276A4680F82738EB4A9671AD2BFFBDA934E068BE\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": \"172113760775\",\n//                     \"Sequence\": 22\n//                   },\n//                   \"PreviousTxnID\": \"18BDA2A877475840B427F8552E946367E0FBA5CC918E065B5CBFE4ED54752DDF\",\n//                   \"PreviousTxnLgrSeq\": 4707221\n//                 }\n//               },\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"-0.5489575198674392\"\n//                     },\n//                     \"Flags\": 2228224,\n//                     \"HighLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rU2DL7DwxxEjkRFV6uuSZtmJiosV5YgetS\",\n//                       \"value\": \"100\"\n//                     },\n//                     \"HighNode\": \"0000000000000000\",\n//                     \"LowLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rfYv1TXnwgDDK4WQNbFALykYuEBnrR4pDX\",\n//                       \"value\": \"0\"\n//                     },\n//                     \"LowNode\": \"000000000000003B\"\n//                   },\n//                   \"LedgerEntryType\": \"RippleState\",\n//                   \"LedgerIndex\": \"D505A48DABB927A1F2A0E0A4A4393320772BDB14F243FBB38B1F89340E7B5D2E\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"-0.5490578701674392\"\n//                     }\n//                   },\n//                   \"PreviousTxnID\": \"1F99E7E9BCFD285793D54F7CB3161745D7C9B615D68EEFA37E3D77044FF6CA2E\",\n//                   \"PreviousTxnLgrSeq\": 4689485\n//                 }\n//               },\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"-0.00112098\"\n//                     },\n//                     \"Flags\": 131072,\n//                     \"HighLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rLpq5RcRzA8FU1yUqEPW4xfsdwon7casuM\",\n//                       \"value\": \"1\"\n//                     },\n//                     \"HighNode\": \"0000000000000000\",\n//                     \"LowLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",\n//                       \"value\": \"0\"\n//                     },\n//                     \"LowNode\": \"00000000000000BB\"\n//                   },\n//                   \"LedgerEntryType\": \"RippleState\",\n//                   \"LedgerIndex\": \"DB50D38DF8AA6F652D7BF58229745D8095FFFA9465130D1C1976AAEBB5C2DCDE\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"-0.00102098\"\n//                     }\n//                   },\n//                   \"PreviousTxnID\": \"72E2970A1CE0CB56A8F11F9E36847E59BA62BEDB7DAD6C0461E36C1E694DFEDC\",\n//                   \"PreviousTxnLgrSeq\": 4699069\n//                 }\n//               }\n//             ],\n//             \"TransactionIndex\": 0,\n//             \"TransactionResult\": \"tesSUCCESS\"\n//           }\n//         },\n//         {\n//           \"Account\": \"rs1KQkwBYW1pY7jGeRiNgBkbD6WkPG4cYE\",\n//           \"Amount\": \"4000000\",\n//           \"Destination\": \"rpyUV8W6XRvss6SBkAS8PyzGwMsSDxgNXW\",\n//           \"DestinationTag\": 2,\n//           \"Fee\": \"12\",\n//           \"Flags\": 0,\n//           \"Sequence\": 9113,\n//           \"SigningPubKey\": \"03441A4ED5967DEB25C52892BA8274EF6E1D7293609C0C4CF7DFF5257230365DDB\",\n//           \"TransactionType\": \"Payment\",\n//           \"TxnSignature\": \"304402207D4F0636474CB5AB61362FAA03AE609F45772FE472E38ACB589DC63BEA779C1C02207058EF9E47C46E51E96703EBAE61E91BB32BC5CD48FF77CAF6CB7980B44295D2\",\n//           \"hash\": \"3F72E3C4C391AD1CE4E436CE68C3D6E16F8BA9FCDE911886D0AA6078BC8D1DF6\",\n//           \"metaData\": {\n//             \"AffectedNodes\": [\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Account\": \"rs1KQkwBYW1pY7jGeRiNgBkbD6WkPG4cYE\",\n//                     \"Balance\": \"2782924305\",\n//                     \"Flags\": 0,\n//                     \"OwnerCount\": 0,\n//                     \"Sequence\": 9114\n//                   },\n//                   \"LedgerEntryType\": \"AccountRoot\",\n//                   \"LedgerIndex\": \"A2A15502645DE43E85253F66C447D05B0A9C9927AA0C544AB0411A123D7FF80A\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": \"2786924317\",\n//                     \"Sequence\": 9113\n//                   },\n//                   \"PreviousTxnID\": \"40AB3BD0DE0A8C952E29B5C45DDA0A18D4EDB27B579ABAF56257D7DC2E93D866\",\n//                   \"PreviousTxnLgrSeq\": 4718675\n//                 }\n//               },\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Account\": \"rpyUV8W6XRvss6SBkAS8PyzGwMsSDxgNXW\",\n//                     \"Balance\": \"1478454471599\",\n//                     \"Flags\": 0,\n//                     \"OwnerCount\": 0,\n//                     \"Sequence\": 228555\n//                   },\n//                   \"LedgerEntryType\": \"AccountRoot\",\n//                   \"LedgerIndex\": \"C754412E25ED3F4257524CED149B993DC1683BDEBE6E0514604008A9B259813B\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": \"1478450471599\"\n//                   },\n//                   \"PreviousTxnID\": \"40AB3BD0DE0A8C952E29B5C45DDA0A18D4EDB27B579ABAF56257D7DC2E93D866\",\n//                   \"PreviousTxnLgrSeq\": 4718675\n//                 }\n//               }\n//             ],\n//             \"TransactionIndex\": 1,\n//             \"TransactionResult\": \"tesSUCCESS\"\n//           }\n//         },\n//         {\n//           \"Account\": \"ra7JkEzrgeKHdzKgo4EUUVBnxggY4z37kt\",\n//           \"Amount\": {\n//             \"currency\": \"USD\",\n//             \"issuer\": \"rMwjYedjc7qqtKYVLiAccJSmCwih4LnE2q\",\n//             \"value\": \"100\"\n//           },\n//           \"Destination\": \"rfUW4KCKvzdA4MCgoft1u5ojuQbpSFRktB\",\n//           \"Fee\": \"10\",\n//           \"Flags\": 0,\n//           \"SendMax\": {\n//             \"currency\": \"USD\",\n//             \"issuer\": \"rMwjYedjc7qqtKYVLiAccJSmCwih4LnE2q\",\n//             \"value\": \"100.00001\"\n//           },\n//           \"Sequence\": 123651,\n//           \"SigningPubKey\": \"02808D78A818D7B27FC43D27A5E793E354A72204E0ACD59A88BB13743FF0F14625\",\n//           \"SourceTag\": 926415956,\n//           \"TransactionType\": \"Payment\",\n//           \"TxnSignature\": \"3046022100EECB7E3083B924EF79F2366A50E8E5E22323E16515C502B47278AABB2E6E79260221008A1D05120284992C63FA75BFE1FB11F8823DD2238FE9DB6DF20185D133F8CA92\",\n//           \"hash\": \"80575096E403379AD2F37A4006FF59A69E9AFD0DF4CA70AC9C4CEE08B1AB5F09\",\n//           \"metaData\": {\n//             \"AffectedNodes\": [\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Account\": \"ra7JkEzrgeKHdzKgo4EUUVBnxggY4z37kt\",\n//                     \"Balance\": \"98863451\",\n//                     \"Flags\": 917504,\n//                     \"OwnerCount\": 1,\n//                     \"Sequence\": 123652\n//                   },\n//                   \"LedgerEntryType\": \"AccountRoot\",\n//                   \"LedgerIndex\": \"D72C5D772234B929C5025423FE111846E4F20EF92269368D4D264A12982FDFE4\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": \"98863461\",\n//                     \"Sequence\": 123651\n//                   },\n//                   \"PreviousTxnID\": \"CC277E6C1063C20D1BA1C922C4081320CD316A330019DE7B479D569C9D5404A0\",\n//                   \"PreviousTxnLgrSeq\": 4718677\n//                 }\n//               }\n//             ],\n//             \"TransactionIndex\": 2,\n//             \"TransactionResult\": \"tecPATH_PARTIAL\"\n//           }\n//         }\n//       ]\n//     });",
          "reduce": "function(keys, values) {\n  var sum = 0;\n  values.forEach(function(val, index){\n    var to_add = parseFloat(val);\n    if (typeof to_add === 'number') {\n      sum += to_add;\n    }\n  });\n  return sum;\n}"
        },
        "transactionStatsByTime": {
          "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( doc.transactions[ t ].metaData.TransactionResult !== \"tesSUCCESS\" ) {\n      return;\n    }\n\n    var value = {};\n    value[ tx.TransactionType ] = 1;\n\n    emit( timestamp, value );\n\n  } );\n}",
          "reduce": "function( keys, values, rereduce ) {\n\n  var stats = {};\n\n  values.forEach( function( val ) {\n    Object.keys( val ).forEach( function( txType ) {\n      if ( !stats[ txType ] ) {\n        stats[ txType ] = 0;\n      }\n\n      stats[ txType ] += val[ txType ];\n    } );\n  } );\n\n  return stats;\n\n}"
        },
        "trustlineBalanceChangesByAccount": {
          "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== \"tesSUCCESS\" )\n      return;\n\n    tx.metaData.AffectedNodes.forEach( function( affNode ) {\n\n      var node = affNode.CreatedNode || affNode.ModifiedNode || affNode.DeletedNode;\n\n      if ( !node || node.LedgerEntryType !== \"RippleState\" ) {\n        return;\n      }\n\n      var currency,\n        highParty,\n        lowParty,\n        prevBal,\n        finalBal,\n        balChange;\n\n      if ( node.NewFields ) {\n\n        // trustline created with non-negative balance\n\n        if ( parseFloat( node.NewFields.Balance.value ) === 0 ) {\n          return;\n        }\n\n        currency = node.NewFields.Balance.currency;\n        highParty = node.NewFields.HighLimit.issuer;\n        lowParty = node.NewFields.LowLimit.issuer;\n\n        prevBal = 0;\n        finalBal = parseFloat( node.NewFields.Balance.value );\n        balChange = finalBal - prevBal;\n\n      } else if ( node.PreviousFields && node.PreviousFields.Balance ) {\n\n        // trustline balance modified\n\n        currency = node.FinalFields.Balance.currency;\n        lowParty = node.FinalFields.LowLimit.issuer;\n        highParty = node.FinalFields.HighLimit.issuer;\n\n        prevBal = parseFloat( node.PreviousFields.Balance.value );\n        finalBal = parseFloat( node.FinalFields.Balance.value );\n        balChange = finalBal - prevBal;\n\n      } else {\n\n        return;\n      }\n\n      emit( [ lowParty, currency ].concat( timestamp ), balChange );\n      emit( [ highParty, currency ].concat( timestamp ), ( 0 - balChange ) );\n\n    } );\n  } );\n}",
          "reduce": "_sum"
        },
        "trustlineBalancesBetweenAccounts": {
          "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== \"tesSUCCESS\" )\n      return;\n\n    tx.metaData.AffectedNodes.forEach( function( affNode ) {\n\n      var node = affNode.CreatedNode || affNode.ModifiedNode;\n\n      if ( !node || node.LedgerEntryType !== \"RippleState\" ) {\n        return;\n      }\n\n      var currency,\n        highParty,\n        lowParty,\n        prevBal,\n        finalBal,\n        balChange;\n\n      if ( node.NewFields ) {\n\n        // trustline created with non-negative balance\n\n        if ( parseFloat( node.NewFields.Balance.value ) === 0 ) {\n          return;\n        }\n\n        currency = node.NewFields.Balance.currency;\n        highParty = node.NewFields.HighLimit.issuer;\n        lowParty = node.NewFields.LowLimit.issuer;\n\n        prevBal = 0;\n        finalBal = parseFloat( node.NewFields.Balance.value );\n        balChange = finalBal - prevBal;\n\n      } else if ( node.PreviousFields && node.PreviousFields.Balance ) {\n\n        // trustline balance modified\n\n        currency = node.FinalFields.Balance.currency;\n        lowParty = node.FinalFields.LowLimit.issuer;\n        highParty = node.FinalFields.HighLimit.issuer;\n\n        prevBal = parseFloat( node.PreviousFields.Balance.value );\n        finalBal = parseFloat( node.FinalFields.Balance.value );\n        balChange = finalBal - prevBal;\n\n      } else {\n\n        return;\n      }\n\n      emit( [ lowParty, currency, highParty ].concat( timestamp ), [ balChange, finalBal ] );\n      emit( [ highParty, currency, lowParty ].concat( timestamp ), [ ( 0 - balChange ), ( 0 - finalBal ) ] );\n\n    } );\n  } );\n}",
          "reduce": "function( keys, values, rereduce ) {\n\n  var results;\n\n  if ( !rereduce ) {\n\n    results = {\n      balanceChange: 0,\n      latestTime: keys[ 0 ][ 0 ].slice( 3 ),\n      latestBalance: values[ 0 ][ 1 ]\n    };\n\n    values.forEach( function( val, index ) {\n\n      var time = keys[ index ][ 0 ].slice( 3 );\n\n      if ( lessThan( results.latestTime, time ) ) {\n\n        results.latestTime = time;\n        results.latestBalance = val[ 1 ];\n\n      }\n\n      results.balanceChange += val[ 0 ];\n\n    } );\n\n  } else {\n\n    results = values[0];\n\n    values.forEach( function( val, index ) {\n\n      // skip values[0]\n      if (index === 0) {\n        return;\n      }\n\n      if ( lessThan( results.latestTime, val.latestTime ) ) {\n\n        results.latestTime = val.latestTime;\n        results.latestBalance = val.latestBalance;\n\n      }\n\n      results.balanceChange += val.balanceChange;\n\n    } );\n\n  }\n\n  return results;\n\n\n  \n\n\n\n  function lessThan( arr1, arr2 ) {\n    if ( arr1.length !== arr2.length )\n      return false;\n\n    for ( var i = 0; i < arr1.length; i++ ) {\n      if ( arr1[ i ] < arr2[ i ] ) {\n        return true;\n      } else if ( arr1[ i ] > arr2[ i ] ) {\n        return false;\n      } else {\n        continue;\n      }\n    }\n\n    return false;\n  }\n}"
        },
        "trustlineStatsByAccount": {
          "map": "function( doc ) {\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== 'tesSUCCESS' ) {\n      return;\n    }\n\n    tx.metaData.AffectedNodes.forEach( function( affNode ) {\n\n      var node = affNode.CreatedNode || affNode.ModifiedNode,\n        currency,\n        trustingParty,\n        trustedParty,\n        trustingPartyLimit,\n        trustedPartyLimit,\n        balanceChange; // represents amount trustingParty is owed\n\n      if ( !node || node.LedgerEntryType !== 'RippleState' ) {\n        return;\n      }\n\n      if ( node.NewFields ) {\n\n        currency = node.NewFields.Balance.currency;\n\n        // determine which of the HighLimit or LowLimit \n        // represent the trustedParty or trustingParty\n        if ( parseFloat( node.NewFields.HighLimit.value ) > 0 ) {\n\n          trustingParty = node.NewFields.HighLimit.issuer;\n          trustedParty = node.NewFields.LowLimit.issuer;\n          balanceChange = 0 - parseFloat( node.NewFields.Balance.value );\n\n        } else if ( parseFloat( node.NewFields.LowLimit.value ) > 0 ) {\n\n          trustingParty = node.NewFields.LowLimit.issuer;\n          trustedParty = node.NewFields.HighLimit.issuer;\n          balanceChange = parseFloat( node.NewFields.Balance.value );\n\n        } else {\n\n          return;\n\n        }\n\n        emit( [ trustingParty, currency ].concat( timestamp ), \n          { outgoing: 1 } );\n\n        emit( [ trustedParty, currency ].concat( timestamp ), \n          { incoming: 1 } );\n\n        if ( balanceChange !== 0 ) {\n\n          emit( [ trustingParty, currency ].concat( timestamp ), \n            { balanceChange: balanceChange } );\n\n          emit( [ trustedParty, currency ].concat( timestamp ), \n            { balanceChange: ( 0 - balanceChange ) } );\n\n        }\n\n      } else if ( node.PreviousFields && node.FinalFields ) {\n\n        currency = node.FinalFields.LowLimit.currency;\n        trustingParty = node.FinalFields.HighLimit.issuer;\n        trustedParty = node.FinalFields.LowLimit.issuer;\n\n      } else {\n\n        return;\n\n      }\n\n\n\n    } );\n\n  } );\n\n\n  for ( var t = 0, txs = doc.transactions.length; t < txs; t++ ) {\n    var tx = doc.transactions[ t ];\n\n\n\n    for ( var n = 0, nodes = tx.metaData.AffectedNodes.length; n < nodes; n++ ) {\n\n      if ( tx.metaData.AffectedNodes[ n ].hasOwnProperty( \"CreatedNode\" ) && tx.metaData.AffectedNodes[ n ].CreatedNode.LedgerEntryType === \"RippleState\" ) {\n        var cnode = tx.metaData.AffectedNodes[ n ].CreatedNode;\n\n        var currency = cnode.NewFields.Balance.currency,\n          high_party = cnode.NewFields.HighLimit.issuer,\n          low_party = cnode.NewFields.LowLimit.issuer;\n\n        if ( parseFloat( cnode.NewFields.LowLimit.value ) > 0 ) {\n          emit( [ high_party, currency ].concat( timestamp ), {\n            incoming: 1\n          } );\n          emit( [ low_party, currency ].concat( timestamp ), {\n            outgoing: 1\n          } ); //, trusted_parties: [high_party]});\n        }\n\n        if ( parseFloat( cnode.NewFields.HighLimit.value ) > 0 ) {\n          emit( [ low_party, currency ].concat( timestamp ), {\n            incoming: 1\n          } );\n          emit( [ high_party, currency ].concat( timestamp ), {\n            outgoing: 1\n          } ); //, trusted_parties: [low_party]});\n        }\n\n        if ( parseFloat( cnode.NewFields.Balance.value ) !== 0 ) {\n          emit( [ high_party, currency ].concat( timestamp ), {\n            balance_change: 0 - parseFloat( cnode.NewFields.Balance.value )\n          } );\n          emit( [ low_party, currency ].concat( timestamp ), {\n            balance_change: parseFloat( cnode.NewFields.Balance.value )\n          } );\n        }\n\n      } else if ( tx.metaData.AffectedNodes[ n ].hasOwnProperty( \"ModifiedNode\" ) && tx.metaData.AffectedNodes[ n ].ModifiedNode.LedgerEntryType === \"RippleState\" ) {\n        var mnode = tx.metaData.AffectedNodes[ n ].ModifiedNode;\n\n        // high limit changed\n        if ( mnode.PreviousFields.hasOwnProperty( \"HighLimit\" ) ) {\n\n          // adding trust line\n          if ( parseFloat( mnode.PreviousFields.HighLimit.value ) === 0 && parseFloat( mnode.FinalFields.HighLimit.value ) > 0 ) {\n\n            var currency = mnode.FinalFields.LowLimit.currency,\n              trusting_party = mnode.FinalFields.HighLimit.issuer,\n              trusted_party = mnode.FinalFields.LowLimit.issuer;\n\n            emit( [ trusted_party, currency ].concat( timestamp ), {\n              incoming: 1\n            } );\n            emit( [ trusting_party, currency ].concat( timestamp ), {\n              outgoing: 1\n            } ); //, trusted_parties: [trusted_party]});\n          }\n\n          // removing trust line\n          if ( parseFloat( mnode.PreviousFields.HighLimit.value ) > 0 && parseFloat( mnode.FinalFields.HighLimit.value ) === 0 ) {\n\n            var currency = mnode.FinalFields.LowLimit.currency,\n              trusting_party = mnode.FinalFields.HighLimit.issuer,\n              trusted_party = mnode.FinalFields.LowLimit.issuer;\n\n            emit( [ trusted_party, currency ].concat( timestamp ), {\n              incoming: -1\n            } );\n            emit( [ trusting_party, currency ].concat( timestamp ), {\n              outgoing: -1\n            } );\n          }\n\n        }\n\n\n        // low limit changed\n        if ( mnode.PreviousFields.hasOwnProperty( \"LowLimit\" ) ) {\n\n          // adding trust line\n          if ( parseFloat( mnode.PreviousFields.LowLimit.value ) === 0 && parseFloat( mnode.FinalFields.LowLimit.value ) > 0 ) {\n\n            var currency = mnode.FinalFields.HighLimit.currency,\n              trusting_party = mnode.FinalFields.LowLimit.issuer,\n              trusted_party = mnode.FinalFields.HighLimit.issuer;\n\n            emit( [ trusted_party, currency ].concat( timestamp ), {\n              incoming: 1\n            } );\n            emit( [ trusting_party, currency ].concat( timestamp ), {\n              outgoing: 1\n            } ); //, trusted_parties: [trusted_party]});\n          }\n\n          // removing trust line\n          if ( parseFloat( mnode.PreviousFields.LowLimit.value ) > 0 && parseFloat( mnode.FinalFields.LowLimit.value ) === 0 ) {\n\n            var currency = mnode.FinalFields.HighLimit.currency,\n              trusting_party = mnode.FinalFields.LowLimit.issuer,\n              trusted_party = mnode.FinalFields.HighLimit.issuer;\n\n            emit( [ trusted_party, currency ].concat( timestamp ), {\n              incoming: -1\n            } );\n            emit( [ trusting_party, currency ].concat( timestamp ), {\n              outgoing: -1\n            } );\n          }\n\n        }\n\n        // balance changed\n        if ( mnode.PreviousFields.hasOwnProperty( \"Balance\" ) ) {\n\n          var currency = mnode.FinalFields.Balance.currency,\n            low_party = mnode.FinalFields.LowLimit.issuer,\n            high_party = mnode.FinalFields.HighLimit.issuer;\n\n          emit( [ low_party, currency ].concat( timestamp ), {\n            balance_change: ( mnode.FinalFields.Balance.value - mnode.PreviousFields.Balance.value )\n          } );\n          emit( [ high_party, currency ].concat( timestamp ), {\n            balance_change: ( 0 - ( mnode.FinalFields.Balance.value - mnode.PreviousFields.Balance.value ) )\n          } );\n\n        }\n      }\n    }\n  }\n}",
          "reduce": "function(keys, values) {\n\n    var results = {\n        \"incoming\": 0,\n        \"outgoing\": 0,\n        \"balance_change\": 0\n    };\n\n    values.forEach(function(val){\n        if (typeof val.incoming === \"number\")\n            results.incoming += val.incoming;\n        if (typeof val.outgoing === \"number\")\n            results.outgoing += val.outgoing;\n        if (typeof val.balance_change === \"number\")\n            results.balance_change += val.balance_change;\n    });\n\n    return results;\n}"
        },
        "xrpBalances": {
          "map": "function( doc ) {\n  var transactions = doc.transactions;\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== \"tesSUCCESS\" ) {\n      return;\n    }\n\n    tx.metaData.AffectedNodes.forEach( function( affNode ) {\n      var node = affNode.ModifiedNode || affNode.CreatedNode || affNode.DeletedNode;\n\n      if ( !node || node.LedgerEntryType !== \"AccountRoot\" ) {\n        return;\n      }\n\n      var fields = node.FinalFields || node.NewFields;\n\n      if ( fields ) {\n        emit( [ fields.Account ].concat( timestamp ), parseInt( fields.Balance, 10 ) );\n      }\n    } );\n  } );\n}",
          "reduce": "function( keys, values, rereduce ) {\n\n  var most_recent = ( rereduce ? values[ 0 ][ 0 ].slice( 1 ) : keys[ 0 ].slice( 1 ) ),\n    acct_balance = ( rereduce ? values[ 0 ][ 0 ] : values[ 0 ] );\n\n  for ( var a = 0, num_keys = keys.length; a < num_keys; a++ ) {\n    var timestamp = ( rereduce ? keys[ a ][ 0 ].slice( 1 ) : keys[ a ].slice( 1 ) );\n\n    if ( lessThan( most_recent, timestamp ) ) {\n      most_recent = timestamp;\n      acct_balance = ( rereduce ? values[ a ][ 0 ] : values[ a ] );\n    }\n  }\n\n  return [ acct_balance ].concat( most_recent );\n\n  function lessThan( arr1, arr2 ) {\n    if ( arr1.length !== arr2.length )\n      return false;\n\n    for ( var i = 0; i < arr1.length; i++ ) {\n      if ( arr1[ i ] < arr2[ i ] ) {\n        return true;\n      } else if ( arr1[ i ] > arr2[ i ] ) {\n        return false;\n      } else {\n        continue;\n      }\n    }\n\n    return false;\n  }\n}"
        }
      }
    }
  ]
}